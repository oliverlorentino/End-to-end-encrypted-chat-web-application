<!DOCTYPE html>
<html lang="en">
<!-- 
This software is provided under the BSD License. Copyright (c) 2024 Xavier de Carné de Carnavalet.
Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the original author is acknowledged. See JavaScript source for full license text.
-->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat Application</title>
    <!-- Bootstrap CSS for styling -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
    <!-- Custom CSS -->
    <link href="{{ url_for('static', filename='styles.css') }}" rel="stylesheet">
</head>
<body>
<div class="container mt-4">
    <h2>Chat Application <small> - (<a href="/logout">Logout</a>)</small></h2>
    <div class="chat-box">
        <!-- Chat messages container -->
        <div id="messages" style="border:1px solid #ccc; height:300px; margin-bottom:20px; overflow-y:scroll; padding:10px;"></div>
        <!-- User selection dropdown -->
        <select id="userList" class="form-control mb-2">
            <option value="-1" disabled selected><i>Choose a contact</i></option>
            <!-- User options populated here -->
        </select>
        <!-- Message input -->
        <textarea id="messageInput" class="form-control mb-2" placeholder="Type a message..."></textarea>
        <div class="d-flex justify-content-between">
            <button onclick="sendMessage()" class="btn btn-primary">Send</button>
            <div>
                <button onclick="refreshKeys()" class="btn btn-secondary btn-sm">Refresh Keys</button>
                <button onclick="eraseChat()" class="btn btn-danger btn-sm">Erase Chat</button>
            </div>
        </div>
    </div>
</div>

<!-- jQuery for simplified JavaScript -->
<script src="https://code.jquery.com/jquery-3.7.1.min.js" integrity="sha384-1H217gwSVyLSIfaLxHbE7dRb3v4mYCKbpQvzx0cegeju1MVsGrX5xXxAvs/HgeFs" crossorigin="anonymous"></script>
<script type="text/javascript">
// Global variables
let lastMessageId = 0;
let peer_id = -1;
const myID = {{ sender_id }};
let userInfo = {};

// Ctrl+Enter to send message
document.addEventListener('DOMContentLoaded', function() {
    document.getElementById('messageInput').addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'Enter') {
            sendMessage();
        }
    });
});

// Send message function
function sendMessage() {
    if (peer_id == -1) return; // Exit if no peer selected
    const message = document.getElementById('messageInput').value;
    encryptMessage(message)
        .then(({ ciphertext, iv, mac }) => {
            // 构建消息payload，符合特定的JSON格式
            const payload = {
                type: "msg",
                receiver_id: peer_id,
                ciphertext: ciphertext,
                IV: iv,
                MAC: mac
            };

            // 发送加密的消息到服务器
            fetch('/send_message', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            })
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                return response.json();
            })
            .then(data => {
                console.log('Message sent:', data);
                document.getElementById('messageInput').value = ''; // 清空输入框
            })
            .catch(error => {
                console.error('Error sending message:', error);
            });
        });
}


// 假设的加密函数，返回一个promise，解析为加密的内容和加密参数
function encryptMessage(messageText) {
    // 实际的加密逻辑----
    // 返回假设的加密结果和参数
    return Promise.resolve({
        ciphertext: 'encrypted_message', // 假设加密内容
        iv: 'initialization_vector', // 假设IV
        mac: 'message_authentication_code' // 假设MAC
    });
}

//假设的函数：
// generateSalt() - 生成新的盐值
// deriveKeys(sharedSecret, salt) - 使用共享密钥和盐值派生新的AES密钥和MAC密钥
// hmac(message, key) - 使用指定的MAC密钥对消息进行HMAC运算
// sendKeyChangeRequest(message, oldMAC, newMAC) - 发送密钥更换请求到对方
// Refresh Keys function placeholder

function refreshKeys() {
    console.log('Refresh keys functionality will be implemented here.');
    // Placeholder for refresh functionality
    const sharedSecret = JSON.parse(localStorage.getItem('SharedSecret'));
    let AESKeys = JSON.parse(localStorage.getItem('AESKeys'));
    let macKeys = JSON.parse(localStorage.getItem('macKeys'));

    // 生成新的盐值
    const newSalt = generateSalt();
    const { newAES, newIV, newMACKey } = deriveKeys(sharedSecret, newSalt);

    // 假设您正在和用户2通信，需要更新AES_1to2, IV_1to2和对应的MAC key
    AESKeys.AES_1to2 = newAES;
    AESKeys.IV_1to2 = newIV;
    macKeys.mac_1to2 = newMACKey;

    // 发送密钥更换请求
    const oldIV = AESKeys.IV_1to2; // 使用旧的IV发送更换请求
    const changeMessage = oldIV + 'change';
    const oldMAC = hmac(changeMessage, macKeys.mac_1to2);
    const newMAC = hmac(changeMessage, newMACKey);

    sendKeyChangeRequest(changeMessage, oldMAC, newMAC);

    // 保存新的密钥信息
    storeInLocal(sharedSecret, AESKeys, macKeys);
    displayMessage('Keys changed');
}

// E2EE - 密钥以及找到对应的key （利用IV）
function getKeyForMessage(IV) {
    // 基于IV或其他标识符选择正确的密钥
    for (let i = keyHistory.length - 1; i >= 0; i--) {
        if (keyHistory[i].IV === IV) {
            return keyHistory[i];
        }
    }
    return null; // 如果找不到匹配的密钥，返回null
}
// E2EE 6- 时间控制
function isKeyExchangeRequestValid(requestTimestamp) {
    const currentTime = Date.now();
    const requestTime = new Date(requestTimestamp).getTime();
    const timeDiff = currentTime - requestTime;

    // 确保请求在最近一分钟内
    return timeDiff >= 0 && timeDiff <= 60000; // 60000毫秒等于1分钟
}

function processKeyExchangeRequest(request) {
    if (isKeyExchangeRequestValid(request.timestamp)) {
        // 处理密钥交换请求
    } else {
        console.log('Key exchange request is outdated and will be ignored.');
    }
}

// Populate users function
function populateUsers(users) {
    const userListDropdown = document.getElementById("userList");
    users.forEach(user => {
        const option = new Option(user[1], user[0]); // username as text, user_id as value
        userListDropdown.add(option);
    });
}

// Fetch users from server
$(document).ready(function() {
    fetch('/users')
        .then(response => response.json())
        .then(data => {
            data.users.forEach(user => {
                userInfo[user[0]] = user[1]; // Map user_id to username
            });
            console.log(userInfo);
            populateUsers(data.users);
        })
        .catch(error => console.error('Error fetching user info:', error));
});

// Handle user selection change
document.getElementById('userList').addEventListener('change', event => {
    peer_id = parseInt(event.target.value, 10); // Convert selected peer_id to integer
    clearChatBox();
    lastMessageId = 0;
    fetchMessages(); // Fetch messages for the new selection
});

// Clear chat box
function clearChatBox() {
    document.getElementById('messages').innerHTML = '';
}

// Fetch messages from server
function fetchMessages() {
    if (peer_id === -1) return; // Exit if no peer selected
    fetch(`/fetch_messages?last_message_id=${lastMessageId}&peer_id=${peer_id}`)
        .then(response => response.json())
        .then(data => {
            data.messages.forEach(message => {
                displayMessage(message);
                lastMessageId = message.message_id;
            });
        })
        .catch(error => console.error('Error fetching messages:', error));
}

// Display a single message
function displayMessage(message) {
    const messagesContainer = document.getElementById('messages');
    const messageElement = document.createElement('div');

    // Determine sender and receiver strings
    const sender = message.sender_id == myID ? "me" : (userInfo[message.sender_id] || `User ${message.sender_id}`);
    const receiver = message.receiver_id == myID ? "me" : (userInfo[message.receiver_id] || `User ${message.receiver_id}`);

    messageElement.textContent = `From ${sender} to ${receiver}: ${message.message_text}`;
    messagesContainer.appendChild(messageElement);
}

// Periodically fetch new messages every second
setInterval(fetchMessages, 1000);

// Erase Chat function using fetch API
function eraseChat() {
    if (peer_id === -1) return; // Exit if no peer selected
    if (!confirm('Are you sure you want to erase the chat with '+userInfo[peer_id]+'?')) return; // Confirmation before erasing

    fetch(`/erase_chat`, {
        method: 'POST',  // A REST API should use POST if it leads to modifications
        headers: {
            'Content-Type': 'application/json', 
        },
        body: JSON.stringify({ peer_id: peer_id })
    })
    .then(response => {
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        return response.json(); // Assuming the server responds with JSON
    })
    .then(data => {
        console.log('Chat erased:', data);
        clearChatBox(); // Clear the chat display
    })
    .catch(error => {
        console.error('Error erasing chat:', error);
    });
}




//**E2EE_4**//
// test data//
//两种结构：一种用char存储，，另一种用数组+json存储，前者结构更加简单，后者结构json复杂，但效率和储存更加方便，
//本函数用后者，前者方法已注释掉
let sharedSecret = 'sharedSecret';
let AESKeys = { AES_1to2: 'AES_1to2', AES_2to1: 'AES_1to2', IV_1to2: 'IV_1to2', 
    IV_2to1: 'IV_2to1'};
let macKeys = { mac_1to2: 'mac_1to2', mac_2to1: 'mac_1to2' };
let keyHistory = JSON.parse(localStorage.getItem('keyHistory')) || [];
function Strore_in_Local(sharedSecret, AESKeys, macKeys ){
    
    keyHistory.push({
        sharedSecret,
        AESKeys,
        macKeys,
        timestamp: new Date().toISOString()  // 添加时间戳用于验证时效性
    });
    if (keyHistory.length > 10) {
        keyHistory.shift();  // 移除最老的密钥集合
    }

    localStorage.setItem('keyHistory', JSON.stringify(keyHistory));
    localStorage.setItem('sharedSecret',JSON.stringify(sharedSecret));
    localStorage.setItem('AESKeys',JSON.stringify(AESKeys));
    localStorage.setItem('macKeys',JSON.stringify(macKeys));
}

function retrieve_Keys(){
    sharedSecret = JSON.parse(localStorage.getItem('sharedSecret'));
    AESKeys = JSON.parse(localStorage.getItem('AESKeys'));
    macKeys = JSON.parse(localStorage.getItem('macKeys'));
    if (sharedSecret && AES_1to2 && AES_2to1 && mac_1to2 && mac_2to1) {
        console.log('Keys retrieved successfully.');
        console.log(sharedSecret);
        console.log(AESKeys);
        console.log(macKeys);
    } else {
        console.log('No keys found in Local Storage.');
        // 显示警告     //**E2EE_5**//
        displayWarning("Warning: Decryption keys are missing. Previous messages cannot be decrypted.");
    }
}
//**E2EE_5**//
// warning的前端样式
function displayWarning(message) {
    const messagesContainer = document.getElementById('messages');
    const warningElement = document.createElement('div');
    warningElement.textContent = message;
    warningElement.style.color = 'red';
    messagesContainer.appendChild(warningElement);
}

// 在密钥交换完成 or 在进行refresh之后调用存储函数：
function after_key_exchange(){
    Strore_in_Local();
}
//在browser 响应后调用检索函数
window.onload = function() {
    retrieveKeys();
};


//**E2EE_7**//
// 初始化共享密钥 
function initiateKeyExchange() {
    // 检查本地存储中是否有共享密钥
    if (!localStorage.getItem('SharedSecret')) {
        // 生成ECDH密钥对并发送公钥到服务器
        generateECDHKeyPair().then(keyPair => {
            // 假设有一个函数将公钥发送到服务器
            sendPublicKeyToServer(keyPair.publicKey);
        });
    }
}

//接收方 
function receiveKeyExchangeRequest(remotePublicKey) {
    // 收到公钥后，生成自己的密钥对并计算共享密钥
    generateECDHKeyPair().then(keyPair => {
        const SharedSecret = computeSharedSecret(keyPair.privateKey, remotePublicKey);
        // 将共享密钥存储在本地存储中，理论上来说，这一步应该在计算共享密钥的函数中实现，如果已经在computeSharedSecret（）实现
        //则可以把下面的删除
        localStorage.setItem('SharedSecret', SharedSecret);
        // 将自己的公钥发送回服务器
        sendPublicKeyToServer(keyPair.publicKey);
    });
}
//提前实现的函数：(周哥的部分)
function generateECDHKeyPair() {
    // 生成ECDH密钥对
}

function computeSharedSecret(privateKey, publicKey) {
    // 使用ECDH计算共享密钥
}

function sendPublicKeyToServer(publicKey) {
    // 将公钥发送到服务器
}




</script>
</body>
</html>
